{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RESPX A utility for mocking out the Python HTTPX library. QuickStart Start by mocking out HTTPX , using respx.mock , and then add desired request patterns to mock your responses. import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert response . status_code == 201 Usage The QuickStart section covers the basics. Continue reading in detail on how Mocking HTTPX is done, or head over to the Developer Interface for a complete guide on how to mock your responses. Installation Install with pip: $ pip install respx Requires Python 3.6+ and HTTPX 0.11.0+. See Changelog for older HTTPX compatibility.","title":"Introduction"},{"location":"#respx","text":"A utility for mocking out the Python HTTPX library.","title":"RESPX"},{"location":"#quickstart","text":"Start by mocking out HTTPX , using respx.mock , and then add desired request patterns to mock your responses. import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert response . status_code == 201","title":"QuickStart"},{"location":"#usage","text":"The QuickStart section covers the basics. Continue reading in detail on how Mocking HTTPX is done, or head over to the Developer Interface for a complete guide on how to mock your responses.","title":"Usage"},{"location":"#installation","text":"Install with pip: $ pip install respx Requires Python 3.6+ and HTTPX 0.11.0+. See Changelog for older HTTPX compatibility.","title":"Installation"},{"location":"api/","text":"Developer Interface Mocking Responses HTTP Method API For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...) Request API For full control, use the core request method. respx. request ( method , url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) Adds a request pattern with given mocked response details. Parameters: method - str | callable Request HTTP method, or Request callback , to match. url - (optional) str | pattern Request exact URL, or URL pattern , to match. status_code - (optional) int - default: 200 Response status code to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . content_type - (optional) str - default text/plain Response Content-Type header value to mock. headers - (optional) dict Response headers to mock. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics . Matching Requests Exact URL To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 ) URL pattern Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used. Base URL When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something (): async with httpx . AsyncClient ( base_url = \"https://foo.bar\" ) as client : request = respx . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\" Request callback For full control of what request to match and what response to mock , pass a callback function as the request(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock def test_something (): custom_request = respx . request ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2 Repeated patterns If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 } Response Content JSON content To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 } Content callback If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" } Request Error To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , content = httpx . ConnectTimeout ()) response = httpx . get ( \"https://foo.bar/\" ) # Will raise Built-in Assertions RESPX has the following build-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) def test_something ( httpx_mock ): httpx_mock . get ( \"https://some.url/\" ) # OK httpx_mock . get ( \"https://foo.bar/\" ) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 with respx . mock ( assert_all_mocked = False ) as httpx_mock : response = httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled . Call Statistics The respx API includes a .calls list, containing captured ( request , response ) tuples, and a .stats MagicMock object with all its bells and whistles , i.e. call_count , assert_called etc. Each mocked response request pattern has its own .calls and .stats , along with .called and .call_count stats shortcuts. To reset stats without stop mocking, use respx.reset() . import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 respx . get ( \"https://foo.bar/\" , alias = \"index\" ) httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert respx . stats . call_count == 2 request , response = respx . calls [ - 1 ] assert request . method == \"GET\" assert response . status_code == 200 respx . reset () assert len ( respx . calls ) == 0 assert respx . stats . call_count == 0","title":"Developer Interface"},{"location":"api/#developer-interface","text":"","title":"Developer Interface"},{"location":"api/#mocking-responses","text":"","title":"Mocking Responses"},{"location":"api/#http-method-api","text":"For regular and simple use, use the HTTP method shorthands. See Request API for parameters. respx. get ( url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) respx. options (...) respx. head (...) respx. post (...) respx. put (...) respx. patch (...) respx. delete (...)","title":"HTTP Method API"},{"location":"api/#request-api","text":"For full control, use the core request method. respx. request ( method , url=None , status_code=None , content=None , content_type=None , headers=None , pass_through=False , alias=None ) Adds a request pattern with given mocked response details. Parameters: method - str | callable Request HTTP method, or Request callback , to match. url - (optional) str | pattern Request exact URL, or URL pattern , to match. status_code - (optional) int - default: 200 Response status code to mock. content - (optional) bytes | str | list | dict | callable | exception - default b\"\" Response content to mock. - See Response Content . content_type - (optional) str - default text/plain Response Content-Type header value to mock. headers - (optional) dict Response headers to mock. pass_through - (optional) bool - default False Mark matched request to pass-through to real server, e.g. don't mock . alias - (optional) str Name this request pattern. - See Call Statistics .","title":"Request API"},{"location":"api/#matching-requests","text":"","title":"Matching Requests"},{"location":"api/#exact-url","text":"To match and mock a request by an exact URL, pass the url parameter as a string . respx . get ( \"https://foo.bar/\" , status_code = 204 )","title":"Exact URL"},{"location":"api/#url-pattern","text":"Instead of matching an exact URL , you can pass a compiled regex to match the request URL. import httpx import re import respx @respx . mock def test_something (): url_pattern = re . compile ( r \"^https://foo.bar/\\w+/$\" ) respx . get ( url_pattern , content = \"Baz\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . text == \"Baz\" Tip Named groups in the regex pattern will be passed as kwargs to the response content callback , if used.","title":"URL pattern"},{"location":"api/#base-url","text":"When adding a lot of request patterns sharing the same domain/prefix, you can configure RESPX with a base_url to use as the base when matching URLs. Like url , the base_url can also be passed as a compiled regex , with optional named groups. import httpx import respx @respx . mock ( base_url = \"https://foo.bar\" ) async def test_something (): async with httpx . AsyncClient ( base_url = \"https://foo.bar\" ) as client : request = respx . get ( \"/baz/\" , content = \"Baz\" ) response = await client . get ( \"/baz/\" ) assert response . text == \"Baz\"","title":"Base URL"},{"location":"api/#request-callback","text":"For full control of what request to match and what response to mock , pass a callback function as the request(method, ...) parameter. The callback's response argument will be pre-populated with any additional response parameters. import httpx import respx def match_and_mock ( request , response ): \"\"\" Return `None` to not match the request. Return the `response` to match and mock this request. Return the `request` for pass-through behaviour. \"\"\" if request . method != \"POST\" : return None if \"X-Auth-Token\" not in request . headers : response . status_code = 401 else : response . content = \"OK\" return response @respx . mock def test_something (): custom_request = respx . request ( match_and_mock , status_code = 201 ) respx . get ( \"https://foo.bar/baz/\" ) response = httpx . get ( \"https://foo.bar/baz/\" ) assert response . status_code == 200 assert not custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 401 assert custom_request . called response = httpx . post ( \"https://foo.bar/baz/\" , headers = { \"X-Auth-Token\" : \"x\" }) assert response . status_code == 201 assert custom_request . call_count == 2","title":"Request callback"},{"location":"api/#repeated-patterns","text":"If you mock several responses with the same request pattern , they will be matched in order, and popped til the last one. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , status_code = 404 ) respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 404 # First match response = httpx . post ( \"https://foo.bar/baz/\" ) assert response . status_code == 201 response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . status_code == 200 # Second match assert response . json () == { \"id\" : 123 }","title":"Repeated patterns"},{"location":"api/#response-content","text":"","title":"Response Content"},{"location":"api/#json-content","text":"To mock a response with json content, pass a list or a dict . The Content-Type header will automatically be set to application/json . import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/baz/123/\" , content = { \"id\" : 123 }) response = httpx . get ( \"https://foo.bar/baz/123/\" ) assert response . json () == { \"id\" : 123 }","title":"JSON content"},{"location":"api/#content-callback","text":"If you need dynamic response content, pass a callback function. When used together with a URL pattern , named groups will be passed as kwargs . import httpx import re import respx def some_content ( request , slug = None ): \"\"\" Return bytes, str, list or a dict. \"\"\" return { \"slug\" : slug } @respx . mock def test_something (): url_pattern = r \"^https://foo.bar/(?P<slug>\\w+)/$\" ) respx . get ( url_pattern , content = some_content ) response = httpx . get ( \"https://foo.bar/apa/\" ) assert response . json () == { \"slug\" : \"apa\" }","title":"Content callback"},{"location":"api/#request-error","text":"To simulate a failing request, like a connection error , pass an Exception instance. This is useful when you need to test proper HTTPX error handling in your app. import httpx import respx @respx . mock def test_something (): respx . get ( \"https://foo.bar/\" , content = httpx . ConnectTimeout ()) response = httpx . get ( \"https://foo.bar/\" ) # Will raise","title":"Request Error"},{"location":"api/#built-in-assertions","text":"RESPX has the following build-in assertion checks: assert_all_mocked Asserts that all captured HTTPX requests are mocked. Defaults to True . assert_all_called Asserts that all mocked request patterns were called. Defaults to True . Configure checks by using the respx.mock decorator / context manager with parentheses. @respx . mock ( assert_all_called = False ) def test_something ( httpx_mock ): httpx_mock . get ( \"https://some.url/\" ) # OK httpx_mock . get ( \"https://foo.bar/\" ) response = httpx . get ( \"https://foo.bar/\" ) assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 with respx . mock ( assert_all_mocked = False ) as httpx_mock : response = httpx . get ( \"https://foo.bar/\" ) # OK assert response . status_code == 200 assert httpx_mock . stats . call_count == 1 Without Parentheses When using the global scope @respx.mock decorator / context manager, assert_all_called is disabled .","title":"Built-in Assertions"},{"location":"api/#call-statistics","text":"The respx API includes a .calls list, containing captured ( request , response ) tuples, and a .stats MagicMock object with all its bells and whistles , i.e. call_count , assert_called etc. Each mocked response request pattern has its own .calls and .stats , along with .called and .call_count stats shortcuts. To reset stats without stop mocking, use respx.reset() . import httpx import respx @respx . mock def test_something (): request = respx . post ( \"https://foo.bar/baz/\" , status_code = 201 ) httpx . post ( \"https://foo.bar/baz/\" ) assert request . called assert request . call_count == 1 respx . get ( \"https://foo.bar/\" , alias = \"index\" ) httpx . get ( \"https://foo.bar/\" ) assert respx . aliases [ \"index\" ] . called assert respx . aliases [ \"index\" ] . call_count == 1 assert respx . stats . call_count == 2 request , response = respx . calls [ - 1 ] assert request . method == \"GET\" assert response . status_code == 200 respx . reset () assert len ( respx . calls ) == 0 assert respx . stats . call_count == 0","title":"Call Statistics"},{"location":"mocking/","text":"Mocking HTTPX To mock out HTTPX , use the respx.mock decorator / context manager. Optionally configure built-in assertion checks and base URL with respx.mock(...) . Using the Decorator import httpx import respx @respx . mock def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" Using the Context Manager import httpx import respx with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() . Global Setup & Teardown pytest # conftest.py import pytest import respx @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" ) as httpx_mock : httpx_mock . get ( \"/user/\" , content = [], alias = \"list_users\" ) ... yield httpx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) request = mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use a session scoped fixture @pytest.fixture(scope=\"session\") when your fixture contains multiple endpoints that not necessary gets called by a single test case, or disable the built-in assert_all_called check. unittest # testcases.py class MockedAPIMixin : def setUp ( self ): self . mocked_api = respx . mock ( base_url = \"https://foo.bar\" ) self . mocked_api . get ( \"/user/\" , content = [], alias = \"list_users\" ) ... self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import unittest import httpx from .testcases import MockedAPIMixin class MyTestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) request = self . mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use setUpClass and tearDownClass when you mock multiple endpoints that not necessary gets called by a single test method, or disable the built-in assert_all_called check. Async Support You can use respx.mock in both sync and async contexts to mock out HTTPX responses. pytest @respx . mock @pytest . mark . asyncio async def test_something (): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) @pytest . mark . asyncio async def test_something (): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa @pytest.fixture ( scope = \"session\" ) async def mocked_api (): async with respx . mock ( base_url = \"https://foo.bar\" ) as httpx_mock : ... yield httpx_mock unittest import asynctest class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_something ( self ): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) async def test_something ( self ): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" )","title":"Mocking HTTPX"},{"location":"mocking/#mocking-httpx","text":"To mock out HTTPX , use the respx.mock decorator / context manager. Optionally configure built-in assertion checks and base URL with respx.mock(...) .","title":"Mocking HTTPX"},{"location":"mocking/#using-the-decorator","text":"import httpx import respx @respx . mock def test_something (): request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\"","title":"Using the Decorator"},{"location":"mocking/#using-the-context-manager","text":"import httpx import respx with respx . mock : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = httpx . get ( \"https://foo.bar/\" ) assert request . called assert response . status_code == 200 assert response . text == \"foobar\" NOTE You can also start and stop mocking HTTPX manually, by calling respx.start() and respx.stop() .","title":"Using the Context Manager"},{"location":"mocking/#global-setup-teardown","text":"","title":"Global Setup &amp; Teardown"},{"location":"mocking/#pytest","text":"# conftest.py import pytest import respx @pytest . fixture def mocked_api (): with respx . mock ( base_url = \"https://foo.bar\" ) as httpx_mock : httpx_mock . get ( \"/user/\" , content = [], alias = \"list_users\" ) ... yield httpx_mock # test_api.py import httpx def test_list_users ( mocked_api ): response = httpx . get ( \"https://foo.bar/users/\" ) request = mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use a session scoped fixture @pytest.fixture(scope=\"session\") when your fixture contains multiple endpoints that not necessary gets called by a single test case, or disable the built-in assert_all_called check.","title":"pytest"},{"location":"mocking/#unittest","text":"# testcases.py class MockedAPIMixin : def setUp ( self ): self . mocked_api = respx . mock ( base_url = \"https://foo.bar\" ) self . mocked_api . get ( \"/user/\" , content = [], alias = \"list_users\" ) ... self . mocked_api . start () def tearDown ( self ): self . mocked_api . stop () # test_api.py import unittest import httpx from .testcases import MockedAPIMixin class MyTestCase ( MockedAPIMixin , unittest . TestCase ): def test_list_users ( self ): response = httpx . get ( \"https://foo.bar/users/\" ) request = self . mocked_api [ \"list_users\" ] assert request . called assert response . json () == [] Tip Use setUpClass and tearDownClass when you mock multiple endpoints that not necessary gets called by a single test method, or disable the built-in assert_all_called check.","title":"unittest"},{"location":"mocking/#async-support","text":"You can use respx.mock in both sync and async contexts to mock out HTTPX responses.","title":"Async Support"},{"location":"mocking/#pytest_1","text":"@respx . mock @pytest . mark . asyncio async def test_something (): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) @pytest . mark . asyncio async def test_something (): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) Session Scoped Fixtures If a session scoped RESPX fixture is used in an async context, you also need to broaden the pytest-asyncio event_loop fixture. You can use the session_event_loop utility for this. # conftest.py import pytest import respx from respx.fixtures import session_event_loop as event_loop # noqa @pytest.fixture ( scope = \"session\" ) async def mocked_api (): async with respx . mock ( base_url = \"https://foo.bar\" ) as httpx_mock : ... yield httpx_mock","title":"pytest"},{"location":"mocking/#unittest_1","text":"import asynctest class MyTestCase ( asynctest . TestCase ): @respx . mock async def test_something ( self ): async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" ) async def test_something ( self ): async with respx . mock : async with httpx . AsyncClient () as client : request = respx . get ( \"https://foo.bar/\" , content = \"foobar\" ) response = await client . get ( \"https://foo.bar/\" )","title":"unittest"}]}